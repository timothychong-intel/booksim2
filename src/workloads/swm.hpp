/*
 * swm.hpp
 *
 * Scalable workload model traffic generator for Booksim
 *
 *  Created on: Jun 9, 2022
 *      Author: cjbeckma
 */

#ifndef SRC_SWM_HPP_
#define SRC_SWM_HPP_

#include <assert.h>
#include <iostream>
#include <vector>
#include <list>
#include <boost/coroutine/all.hpp>
#include "config_utils.hpp"
#include "misc_utils.hpp"
#include "globals.hpp"
#include "swm_globals.hpp"
#include "wkld_msg.hpp"



//
// class representing a single thread or process
//

static int sim_terminate = 0;

class SwmThread {
  public:
    typedef uint64_t cycle_t;                   // time in cycles

  protected:
    // SWM behavioral interface
    //   you can write a workload behavioral routine as a method on this class.
    //   It has access to the following API for defining the workload behavior:
    const int _me;                              // my process ID
    const int _np;                              // total number of processes


    int _put = 0;
    int _get = 0;
    int _send = 0;
    int _reply = 0;


    void      thread_yield();                   // yield to another thread by sending dummy message

    void      work(cycle_t);                    // simulate <c> cycles of local work (i.e. delay for c cycles)
    void      put(int sz, int tgt);             // PUT request of size <sz> bytes to PE <tgt>. Generates a WRITE request
    void      get(int sz, int tgt);             // GET request of size <sz> bytes from <tgt>. Generates a READ request,
    void      getnb(int sz, int tgt);           // Nonblocking GET request of size <sz> bytes from <tgt>. Generates a READ request,
    //   and blocks until response received
    void      send(int sz, int tgt);            // Send a message of size <sz> bytes to PE <tgt>
    void      recv(int tgt);                    // Receive a message from <tgt>.  Blocks until msg received.

    void      quiet();                          // Used to wait for reply messages

    void      reset()  { _state = message; _time = 0; }
    cycle_t   get_time() const { return _time; }
    void      set_time(cycle_t time) {  _time = time;}

#if DEBUG > 0
#   define    DBGPRINT(x) \
    std::cout << "CYC " << get_time() << " PE " << _me << ' ' << x << std::endl
#else
#   define    DBGPRINT(x)
#endif

  public:


    // Generator interface
    //   a traffic injector invokes this to run the model and generate message traffic:
    //
    struct pkt_s {                              // outgoing message generated by workload model
      WorkloadMessage::msg_t type;
      int   marker;                           //   marker for RoI
      int   source;                           //   source process ID
      int   dest;                             //   destination process ID
      int   size;                             //   payload size in bytes
      bool  is_reply;

      struct pkt_s reply() {                  //   create a reply packet to this request
        assert(!is_reply);
        return pkt_s({type, 0, dest, source, size, true});
      }
    };

    int       get_id() const                    { return _me; }
    bool      has_packet(cycle_t now) const     {
      //if(_state == message && _time <= now)
      //printf("[%d] test %d _time %d now %d\n", _me, _state == message && _time <= now, _time, now);
      return _state == message && _time <= now; }
    pkt_s     get_packet() const                { return _coro->get(); }
    void      next(cycle_t);                    // after getting outgoing packet, run and generate next packet
    void      reply(cycle_t, const pkt_s &);    // provide reply and run
    void      sendin(cycle_t, const pkt_s &);   // provide incoming SEND and run
    bool      is_done() const                   { return _state == done; }
    void      set_done()  { _state = done; }
    bool      is_quiet() { return _state == quiet_wait; }

    Configuration const * getConfig()     { return _config; }



    // public interface for put/get/send/recv
    void      PUT(int sz, int tgt) { put(sz, tgt); }     // PUT request of size <sz> bytes to PE <tgt>. Generates a WRITE request
    void      GET(int sz, int tgt) { get(sz, tgt); }     // GET request of size <sz> bytes from <tgt>. Generates a READ request,
    // and blocks until response received
    void      GETNB(int sz, int tgt) { getnb(sz, tgt); } // Nonblocking GET request of size <sz> bytes from <tgt>. Generates a READ request,
    void      SEND(int sz, int tgt) { send(sz, tgt); }   // Send a message of size <sz> bytes to PE <tgt>
    void      RECV(int tgt) { recv(tgt); }               // Receive a message from <tgt>.  Blocks until msg received.
    void      QUIET() { quiet(); }
    void      WORK(cycle_t w) { work(w); }
    void      YIELD() { thread_yield(); }

    void    SwmMarker(int marker);
    void    SwmEndMarker(int marker);
    void    SwmReset() { reset(); }
    cycle_t getTime() { return get_time(); }

    // Notify booksim to clear the stats
    void clear_stats();

    // construction and initialization
    struct factory_base {                       // factory base class
      virtual SwmThread *make(int, int, Configuration const * const) = 0;
    };
    template <class SUB>
      struct factory : public factory_base {      // workload-specific factory
        virtual SwmThread *make(int id, int np, Configuration const * const config) { return new SUB(id, np, config); }
      };
  protected:
    SwmThread(int id, int np, Configuration const * const config)                   // private constructor
      : _me(id), _np(np), _state(ready), _time(0), _coro(0), _config(config),  _outstanding_acks(0), _track_acks(config->GetInt("use_read_write")){}

    void      start();                          // start coroutine running after derived class initialized

  private:
    // behavioral routine - the workload model
    virtual void behavior(int argc, char * argv[]) = 0;                // derived classes provide workload behavior

    // internal types
    //
    enum    state_t { ready, message, wait, quiet_wait, done };
    typedef boost::coroutines::asymmetric_coroutine<pkt_s>::pull_type coro_t;
    typedef boost::coroutines::asymmetric_coroutine<pkt_s>::push_type sink_t;

    // internal data members
    state_t          _state;
    cycle_t          _time;
    cycle_t          _msg_overhead;
    cycle_t          _put_overhead;
    cycle_t          _get_overhead;
    cycle_t          _send_overhead;
    cycle_t          _recv_overhead;
    coro_t *         _coro;
    sink_t *         _sink;
    std::list<pkt_s> _recvd;                    // unmatched received messages

    //
    Configuration const * const  _config;
    std::list<pkt_s> _outstanding_acks;         // keep track of acks and replies
    bool _track_acks;


    void parse_args(int &argc, char ** &argv) {

      string args = _config->GetStr("swm_args");
      vector<string> arg_tokens = tokenize_str(args);


      // Create the `argv` array.
      argc = arg_tokens.size()+1;
      argv = new char*[argc + 1];
      string name = "swm";
      argv[0] = new char[name.length()+1];
      strcpy(argv[0], name.c_str());
      for (int i = 1; i < argc; ++i) {
        argv[i] = new char[arg_tokens[i-1].length() + 1];
        strcpy(argv[i], arg_tokens[i-1].c_str());
      }
      argv[argc] = nullptr;
    }


    // internal methods
    void      wrapper(sink_t &sink) {

      // Get message overhead in cycles
      _msg_overhead = _config->GetInt("swm_msg_overhead");
      _put_overhead = _msg_overhead;
      _get_overhead = _msg_overhead;
      _send_overhead = _msg_overhead;
      _recv_overhead = _msg_overhead;

      _sink = &sink;

      gSwm = true;
      if(!_config->GetInt("roi")) {
        gSimEnabled = true;
      }

      // parse arguments for the swm workloads
      int argc=0;
      char ** argv=nullptr;
      parse_args(argc, argv);

      // SWM behavior
      behavior(argc, argv);

      // wait for the completion of outstanding
      // requests and replies
      quiet();

      _state = done;

      sim_terminate++;

      if(sim_terminate == _np)
        gSimEnabled = false;
    }
    bool      is_waiting(const pkt_s &) const;  // is the process waiting for a reply or a send?
    void      go(cycle_t);                      // run the model to generate the next packet
};


// macros for declaration boilerplate
#define SWM_CLASS(_c_) class _c_ : public SwmThread
#define SWM_INIT(_c_)  public: _c_(int id, int np, Configuration const * const config) : SwmThread(id, np, config) { start(); }


#endif /* SRC_SWM_HPP_ */
